#+Title: Emacs-Make

Test Elisp with services like Travis CI without the fuss of Cask --
just you, your project, and (Emacs-)Make.

Things EMake does:
- parses, installs, and runs tests for your package
- provides all the power of Elisp to extend its capabilities on-demand

Things EMake will never do (or 'reasons you may still need Cask'):
- manage your development environment or provide tools to do so
- provide '[[https://bundler.io][bundler]]-like' =exec= abilities (this includes Cask's =emacs=
  and =eval= commands)

* Using EMake
A practical demonstration is available in the =example= submodule which
is also [[https://github.com/vermiculus/emake.el-example][hosted on GitHub]] and [[https://travis-ci.org/vermiculus/emake.el-example][hooked up to Travis]].

EMake itself is driven by a few environment variables:
- =PACKAGE_FILE= :: This is the Elisp file that contains the definition
                    of your package (e.g., =Author=, =Package-Version=,
                    =Keywords=, etc.)
- =PACKAGE_TESTS= :: This is the Elisp file that is loaded before
     running tests.
- =PACKAGE_LISP= :: This contains a space-delimited list of files to be
                    considered part of the package.
- =PACKAGE_ARCHIVES= :: This contains a space-delimited list of
     =package.el= archives to use for resolving dependencies.
If your test suite has extra dependencies that shouldn't be proper
dependencies of the project as a whole, you can tell EMake what to do
by configuring the following environment variables:
- =PACKAGE_TEST_DEPS= :: This contains a space-delimited list of
     package-names your test suite is dependent upon.
- =PACKAGE_TEST_ARCHIVES= :: These archives will be used to install the
     dependencies in =PACKAGE_TEST_DEPS= (and their dependencies, ...).

The entry point to EMake is the function ~emake~ and is intended to be
invoked as follows:
#+BEGIN_SRC sh
emacs -batch -l emake.el --eval "(emake (pop argv))" target [args...]
#+END_SRC
Of course, seeing as EMake would know nothing of your project if
invoked like this, you should set the environment before the command:
#+BEGIN_SRC sh
PACKAGE_FILE="pkg.el"
PACKAGE_LISP="pkg.el"
PACKAGE_TESTS="pkg-test.el"
PACKAGE_ARCHIVES="gnu melpa"
#+END_SRC
In Make, it's easiest to do the following:
#+BEGIN_SRC makefile
EENVS := PACKAGE_FILE="pkg.el" PACKAGE_LISP="pkg.el" PACKAGE_TESTS="pkg-test.el" PACKAGE_ARCHIVES="gnu melpa"
EMAKE := $(EENVS) emacs -batch -l emake.el --eval "(emake (pop argv))"
ETARGETS := install compile test

.PHONY: $(ETARGETS)

$(ETARGETS):
	$(EMAKE) $@
#+END_SRC
This sets up =install=, =compile=, and =test= as targets to be handled by
EMake so that it can be invoked as, e.g., =make install=.

In this directory, you'll find =sample.el=, =test-sample.el=, a =Makefile=,
and a =.travis.yml= that demonstrates how to effectively use
[[https://github.com/flycheck/emacs-travis][=emacs-travis.mk=]] and EMake to test your packages.

* Extending EMake
Targets can be created (or overridden) by defining a function called
=emake-my-TARGET= (where =TARGET= is the name of your custom target)
before calling the ~emake~ function.

For example, if =custom-targets.el= contains a custom target called
~emake-my-cake~ and you invoke EMake as
#+BEGIN_SRC sh
emacs -batch -l emake.el -l custom-targets.el --eval "(emake (pop argv))"
#+END_SRC
and run ~make cake~, your function ~emake-my-cake~ will be executed after
some output boilerplate.

You may find ~emake-with-elpa~, =emake-project-root=, and
=emake-package-desc= helpful (along with the ~package-desc-~ family of
cl-struct accessors provided by =package.el=).

If your target is generalized and generally useful, consider
contributing it to this repository!
