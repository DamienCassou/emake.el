#+Title: Emacs-Make

Test Elisp with services like Travis CI without the fuss of Cask --
just you, your project, and (Emacs-)Make.

Things EMake does:
- parses, installs, and runs tests for your package
- provides all the power of Elisp to extend its capabilities on-demand

Things EMake will never do (or 'reasons you may still need Cask'):
- manage your development environment or provide tools to do so
- provide '[[https://bundler.io][bundler]]-like' =exec= abilities (this includes Cask's =emacs=
  and =eval= commands)

* Using EMake
A practical demonstration is available in the =example= submodule which
is also [[https://github.com/vermiculus/emake.el-example][hosted on GitHub]] and [[https://travis-ci.org/vermiculus/emake.el-example][hooked up to Travis]].

EMake itself is driven by a few environment variables:
- =PACKAGE_FILE= :: This is the Elisp file that contains the definition
                    of your package (e.g., =Author=, =Package-Version=,
                    =Keywords=, etc.)
- =PACKAGE_TESTS= :: This is the Elisp file that is loaded before
     running tests.
- =PACKAGE_LISP= :: This contains a space-delimited list of files to be
                    considered part of the package.
- =PACKAGE_ARCHIVES= :: This contains a space-delimited list of
     =package.el= archives to use for resolving dependencies.
If your test suite has extra dependencies that shouldn't be proper
dependencies of the project as a whole, you can tell EMake what to do
by configuring the following environment variables:
- =PACKAGE_TEST_DEPS= :: This contains a space-delimited list of
     package-names your test suite is dependent upon.
- =PACKAGE_TEST_ARCHIVES= :: These archives will be used to install the
     dependencies in =PACKAGE_TEST_DEPS= (and their dependencies, ...).

The entry point to EMake is the function ~emake~ and is intended to be
invoked as follows:
#+BEGIN_SRC sh
emacs -batch -l emake.el --eval "(emake (pop argv))" target [args...]
#+END_SRC

Since this is just Elisp, other setup can be made by just evaluating
some lisp in this invocation or loading an external file.  You might
want to set ~byte-compile-error-on-warn~, for example, or maybe define
new testing frameworks by extending ~emake-test-runner-master-alist~.
It's just Elisp -- no funny business!

** Default Targets
EMake comes with a few default targets to give it some out-of-the-box
functionality.

*** =install=
Invoking =$(EMAKE) install= parses =PACKAGE_FILE= to install all its noted
dependencies (in the =Package-Requires= header) from =PACKAGE_ARCHIVES=.

*** =compile=
Invoking =$(EMAKE) compile= byte-compiles all files in =PACKAGE_LISP=.

*** =test=
Invokine =$(EMAKE) test= kicks off the automated tests for your project.
If you're using a framework that can't discover test definitions for
you, you can define =PACKAGE_TESTS= to be the file to load those
definitions from before running the tests.

You can specify which framework to use with an additional argument:
=$(EMAKE) test ert= tests with ERT (the default) and =$(EMAKE) test
buttercup= tests with Buttercup.  Other frameworks may be defined in or
added to ~emake-test-runner-master-alist~.

* Extending EMake
Targets can be created (or overridden) by defining a function called
=emake-my-TARGET= (where =TARGET= is the name of your custom target)
before calling the ~emake~ function.

For example, if =custom-targets.el= contains a custom target called
~emake-my-cake~ and you invoke EMake as
#+BEGIN_SRC sh
emacs -batch -l emake.el -l custom-targets.el --eval "(emake (pop argv))"
#+END_SRC
and run ~make cake~, your function ~emake-my-cake~ will be executed after
some output boilerplate.

You may find ~emake-with-elpa~, =emake-project-root=, and
=emake-package-desc= helpful (along with the ~package-desc-~ family of
cl-struct accessors provided by =package.el=).

If your target is generalized and generally useful, consider
contributing it to this repository!
